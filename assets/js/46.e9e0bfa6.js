(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{467:function(v,_,e){"use strict";e.r(_);var c=e(2),t=Object(c.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AFreact%E5%92%8Cvue"}},[v._v("一、什么是 react 和 vue")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E4%BA%8C%E3%80%81%E5%85%B1%E5%90%8C%E7%82%B9"}},[v._v("二、共同点")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E4%B8%89%E3%80%81%E4%B8%8D%E5%90%8C%E7%82%B9"}},[v._v("三、不同点")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E5%9B%9B%E3%80%81%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB"}},[v._v("四、语法区别")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E4%BA%94%E3%80%81react%E5%92%8Cvue%E7%9A%84%E9%80%89%E6%8B%A9"}},[v._v("五、react 和 vue 的选择")])])]),v._v(" "),_("h2",{attrs:{id:"一、什么是-react-和-vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是-react-和-vue"}},[v._v("#")]),v._v(" 一、什么是 react 和 vue")]),v._v(" "),_("p",[_("strong",[v._v("react")])]),v._v(" "),_("p",[_("code",[v._v("React")]),v._v("是由"),_("code",[v._v("Facebook")]),v._v("开发的用于构建用户界面的"),_("code",[v._v("JavaScript")]),v._v("库，"),_("code",[v._v("React")]),v._v("主张是"),_("code",[v._v("函数式编程")]),v._v("的理念。实现了\n前端界面的高性能开发。很擅长处理组件化的页面。在"),_("code",[v._v("React")]),v._v("中，所有的组件的渲染都依靠"),_("code",[v._v("jsx")]),v._v("，它是\n"),_("code",[v._v("JavaScript")]),v._v("的语法扩展。它在创建"),_("code",[v._v("UI")]),v._v("组件和调试时非常方便。")]),v._v(" "),_("p",[_("strong",[v._v("vue")])]),v._v(" "),_("p",[_("code",[v._v("Vue")]),v._v("是一个渐进式"),_("code",[v._v("JavaScript")]),v._v("框架，"),_("code",[v._v("Vue")]),v._v("的核心库只关注视图层，易于上手，可以与第三方库或既有项目整合。")]),v._v(" "),_("h2",{attrs:{id:"二、共同点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、共同点"}},[v._v("#")]),v._v(" 二、共同点")]),v._v(" "),_("ol",[_("li",[v._v("数据驱动视图")]),v._v(" "),_("li",[v._v("组件化")]),v._v(" "),_("li",[v._v("虚拟 DOM")]),v._v(" "),_("li",[v._v("单向数据流")]),v._v(" "),_("li",[v._v("响应式数据")])]),v._v(" "),_("h2",{attrs:{id:"三、不同点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、不同点"}},[v._v("#")]),v._v(" 三、不同点")]),v._v(" "),_("ol",[_("li",[v._v("核心思想不同：")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v("的定位是尽可能的降低前端开发的门槛，让更多的开发者能够更快的上手开发，所以他的特点是：灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化跟敏感、更精确。")]),v._v(" "),_("li",[_("code",[v._v("react")]),v._v("从一开始的定位就是提出 "),_("code",[v._v("UI")]),v._v(" 开发的新思路，所以"),_("code",[v._v("React")]),v._v("推崇函数式编程(纯组件)，数据不可变以及单向数据流，当然需要双向的地方也可以手动实现，比如借助"),_("code",[v._v("onChange")]),v._v("和"),_("code",[v._v("setState")]),v._v("来实现。")])]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("响应式原理不同：")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v(" 依赖收集，自动优化，数据可变。"),_("code",[v._v("vue")]),v._v(" 递归监听 "),_("code",[v._v("data")]),v._v(" 的所有属性，直接修改。当数据改变时，自动找到引用组件重新渲染")]),v._v(" "),_("li",[_("code",[v._v("react")]),v._v("基于状态机，手动优化，数据不可变，需要"),_("code",[v._v("setState")]),v._v("驱动新的"),_("code",[v._v("state")]),v._v("替换老的"),_("code",[v._v("state")]),v._v("，但数据改变时，以组件为根目录，默认全部重新渲染，所以"),_("code",[v._v("react")]),v._v("中会需要"),_("code",[v._v("shouldComponentUpdate")]),v._v("来优化性能。")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("组件写法差异：")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v("推荐的做法是"),_("code",[v._v("template")]),v._v("的单文件组件格式(简单易懂，从传统前端转过来易于理解)，即"),_("code",[v._v("html、js、css")]),v._v("写在一个文件中(也支持"),_("code",[v._v("jsx")]),v._v("语法，但官方不推荐)。")]),v._v(" "),_("li",[_("code",[v._v("react")]),v._v("推荐的做法是"),_("code",[v._v("JSX + inline style")]),v._v("，也就是把"),_("code",[v._v("HTML")]),v._v("和"),_("code",[v._v("CSS")]),v._v("全都写进"),_("code",[v._v("javascript")]),v._v("中，即"),_("code",[v._v("all in js")]),v._v("。")])]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("diff 算法不同：")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v("的 "),_("code",[v._v("diff")]),v._v(" 算法是"),_("code",[v._v("双端比较")]),v._v("，"),_("code",[v._v("vue")]),v._v("在比较两组节点时，会从两端开始比较，如果两端都相同，则继续向中间比较，直到找到不同的节点。在对比节点时，当节点元素相同，但 "),_("code",[v._v("className")]),v._v(" 不同，认为是不同类型的元素，删除重建。")]),v._v(" "),_("li",[_("code",[v._v("react")]),v._v("的 diff 算法是"),_("code",[v._v("单向比较")]),v._v("，"),_("code",[v._v("react")]),v._v("在比较两组节点时，会从"),_("code",[v._v("父节点")]),v._v("开始比较，如果"),_("code",[v._v("父节点")]),v._v("相同，则继续比较"),_("code",[v._v("子节点")]),v._v("，直到找到不同的节点。在对比节点时，当节点元素相同，但 "),_("code",[v._v("className")]),v._v(" 不同，认为是同类型的元素，只是修改节点属性。")])]),v._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[v._v("渲染过程：")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v("的渲染过程是："),_("code",[v._v("template")]),v._v(" -> "),_("code",[v._v("AST")]),v._v(" -> "),_("code",[v._v("render")]),v._v(" -> "),_("code",[v._v("Virtual DOM")]),v._v(" -> "),_("code",[v._v("UI")]),v._v("，\n"),_("code",[v._v("vue")]),v._v("可以更快的计算出"),_("code",[v._v("Virtual DOM")]),v._v("的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。")]),v._v(" "),_("li",[_("code",[v._v("react")]),v._v("的渲染过程是："),_("code",[v._v("JSX")]),v._v(" -> "),_("code",[v._v("JS")]),v._v(" -> "),_("code",[v._v("Virtual DOM")]),v._v(" -> "),_("code",[v._v("UI")]),v._v("，"),_("code",[v._v("ract")]),v._v("在应用的状态被改变时，全部子组件都会重新渲染。通过"),_("code",[v._v("shouldComponentUpdate")]),v._v("这个方法可以进行控制，但"),_("code",[v._v("vue")]),v._v("视为默认行为。")])]),v._v(" "),_("ol",{attrs:{start:"6"}},[_("li",[_("p",[v._v("vuex 和 redux：")]),v._v(" "),_("p",[v._v("从表面上来说，"),_("code",[v._v("store")]),v._v("注入和使用方式有些区别")])])]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("vuex")]),v._v("中，"),_("code",[v._v("$store")]),v._v("被直接注入到了组件实例中，因此可以比较灵活的使用：使用"),_("code",[v._v("dispatch")]),v._v("、"),_("code",[v._v("commit")]),v._v("提交更新，通过"),_("code",[v._v("mapState")]),v._v("或者直接通过"),_("code",[v._v("this.$store.state.xxx")]),v._v("获取状态。在组件中既可以"),_("code",[v._v("disopatch actions")]),v._v("，也可以"),_("code",[v._v("commit updates")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("在 "),_("code",[v._v("redux")]),v._v(" 中，我们每一个组件都需要显示的用"),_("code",[v._v("connect")]),v._v("方法把需要的"),_("code",[v._v("props")]),v._v("和"),_("code",[v._v("dispatch")]),v._v("进行连接，并且通过"),_("code",[v._v("dispatch")]),v._v("和"),_("code",[v._v("mapStateToProps")]),v._v("进行提交和获取状态。在 "),_("code",[v._v("redux")]),v._v(" 中只能进行"),_("code",[v._v("dispatch")]),v._v("，不能直接调用"),_("code",[v._v("reducer")]),v._v("进行修改。")]),v._v(" "),_("p",[v._v("从实现原理上来说："),_("code",[v._v("redux")]),v._v(" 使用的是不可变数据，而 "),_("code",[v._v("vuex")]),v._v(" 使用的可变数据。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("Redux")]),v._v(" 每次都是用新 "),_("code",[v._v("state")]),v._v(" 替换旧 "),_("code",[v._v("state")]),v._v("，而 "),_("code",[v._v("Vuex")]),v._v(" 是直接修改。"),_("code",[v._v("Redux")]),v._v(" 在检测数据变化的时候，是通过 "),_("code",[v._v("diff")]),v._v(" 的方式比较差异的，而 "),_("code",[v._v("Vuex")]),v._v(" 其实和 "),_("code",[v._v("Vue")]),v._v(" 的原理一样，是通过 "),_("code",[v._v("getter/setter")]),v._v(" 来比较的，这两点的区别，也是因为 "),_("code",[v._v("React")]),v._v(" 和 "),_("code",[v._v("Vue")]),v._v(" 的设计理念不同。"),_("code",[v._v("React")]),v._v(" 更偏向于构建稳定大型的应用，非常的科班化。相比之下，"),_("code",[v._v("Vue")]),v._v(" 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用 "),_("code",[v._v("React")]),v._v("，小型项目用 "),_("code",[v._v("Vue")]),v._v(" 的感觉。")])])]),v._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[v._v("框架：")])]),v._v(" "),_("ul",[_("li",[v._v("vue 本质是 MVVM 框架，由 MVC 发展而来")]),v._v(" "),_("li",[v._v("react 是前端组件化框架，由后端组件化发展而来")])]),v._v(" "),_("h2",{attrs:{id:"四、语法区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、语法区别"}},[v._v("#")]),v._v(" 四、语法区别")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v(" 模板语法："),_("code",[v._v("{{}}")]),v._v("; "),_("code",[v._v("react")]),v._v(" 模板语法："),_("code",[v._v("{}")])]),v._v(" "),_("li",[_("code",[v._v("vue")]),v._v(" 组件语法："),_("code",[v._v("<template>")]),v._v("; "),_("code",[v._v("react")]),v._v(" 组件语法："),_("code",[v._v("<div>")])]),v._v(" "),_("li",[_("code",[v._v("vue")]),v._v(" 事件语法："),_("code",[v._v("@click")]),v._v("; "),_("code",[v._v("react")]),v._v(" 事件语法："),_("code",[v._v("onClick")])]),v._v(" "),_("li",[_("code",[v._v("vue")]),v._v(" 属性语法："),_("code",[v._v(":")]),v._v("; "),_("code",[v._v("react")]),v._v(" 属性语法："),_("code",[v._v("=")])]),v._v(" "),_("li",[_("code",[v._v("vue")]),v._v(" 条件语法："),_("code",[v._v("v-if")]),v._v("; "),_("code",[v._v("react")]),v._v(" 条件语法："),_("code",[v._v("if")])]),v._v(" "),_("li",[_("code",[v._v("vue")]),v._v(" 循环语法："),_("code",[v._v("vue")]),v._v(" 循环 "),_("code",[v._v("dom")]),v._v(" 是在 "),_("code",[v._v("html")]),v._v(" 里面使用 "),_("code",[v._v("v-for")]),v._v(" 指令来进行循环，"),_("code",[v._v("react")]),v._v(" 是使用"),_("code",[v._v("{数组.map((循环出来的数据,下表)=>{})}")]),v._v("来进行循环的")]),v._v(" "),_("li",[_("code",[v._v("vue")]),v._v(" 样式语法："),_("code",[v._v(":class")]),v._v("; "),_("code",[v._v("react")]),v._v(" 样式语法："),_("code",[v._v("className")])])]),v._v(" "),_("h2",{attrs:{id:"五、react-和-vue-的选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、react-和-vue-的选择"}},[v._v("#")]),v._v(" 五、react 和 vue 的选择")]),v._v(" "),_("p",[_("strong",[v._v("在以下情况选择 vue")])]),v._v(" "),_("ol",[_("li",[v._v("最新文档和更简单的语法。")]),v._v(" "),_("li",[v._v("更小，更快，更灵活。")]),v._v(" "),_("li",[v._v("需要丰富的 HTML 模板，易于开发。")])]),v._v(" "),_("p",[_("strong",[v._v("在以下的情况选择 react")])]),v._v(" "),_("ol",[_("li",[v._v("需要构建移动应用程序。")]),v._v(" "),_("li",[v._v("需要构建大型应用程序。")]),v._v(" "),_("li",[v._v("轻量级，易于版本迁移。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);